(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{592:function(e,t,n){"use strict";n.r(t);var a=n(13),s=Object(a.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h3",{attrs:{id:"objectentries"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#objectentries"}},[e._v("#")]),e._v(" ObjectEntries")]),e._v(" "),n("p",[n("a",{attrs:{href:"https://github.com/type-challenges/type-challenges/blob/main/questions/02946-medium-objectentries/README.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("type-challenge-ObjectEntries github地址"),n("OutboundLink")],1)]),e._v(" "),n("p",[e._v("难度：中等")]),e._v(" "),n("h4",{attrs:{id:"题目描述"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#题目描述"}},[e._v("#")]),e._v(" 题目描述")]),e._v(" "),n("p",[e._v("Implement the type version of "),n("code",[e._v("Object.entries")])]),e._v(" "),n("blockquote",[n("p",[e._v("(实现类型的Object.entries函数😂)")])]),e._v(" "),n("p",[e._v("For example:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("interface Model {\n  name: string;\n  age: number;\n  locations: string[] | null;\n}\n\ntype modelEntries = ObjectEntries<Model>\n// ['name', string] | ['age', number] | ['locations', string[] | null];\n")])])]),n("p",[e._v("😂这道题一开始也是没有思路，在看了一些别人实现的方法后，逐渐有了一点思路，这道题第一个问题是"),n("strong",[e._v("如何将对象类型转化为数组类型")]),e._v("🤔。我们可以通过索引来解决这个问题:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("type A = [1, 2, 3][number] // 1 | 2 | 3\n\nconst obj = { name: 'xiao', age: 25 };\n\ntype B = (typeof A)[keyof typeof A] // string | number\n")])])]),n("p",[e._v("这样的话，可以实现第一版的功能")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("type ObjectEntries<T> = {\n  [K in keyof T]: [K, T[K]]\n}[keyof T];\n")])])]),n("p",[e._v("但是"),n("code",[e._v("Equal<ObjectEntries<{ key?: undefined }>, ['key', undefined]>")]),e._v("测试用例的校验无法通过，可以看到这里将可选属性转化为必选属性，可以得到第二个版本的代码")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("type ObjectEntries<T> = {\n  [K in keyof T]-?: [K, T[K]]\n}[keyof T]\n")])])]),n("p",[e._v("🤣"),n("code",[e._v("Equal<ObjectEntries<Partial<Model>>, ModelEntries>")]),e._v("这个测试用例也无法通过，其中"),n("code",[e._v("ModelEntries")]),e._v("类型为"),n("code",[e._v("type ModelEntries = ['name', string] | ['age', number] | ['locations', string[] | null]")]),e._v(","),n("code",[e._v("Partial")]),e._v("是内置的类型函数，将所有属性转化为可选，对应属性的类型就是原类型与undefined的联合类型，我们通过"),n("code",[e._v("extends")]),e._v("进行判断，如果原类型本来就是undefined，直接返回undefined，否则排除undefined类型")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("type ObjectEntries<T> = {\n  [K in keyof T]: [K, [T[K]] extends [undefined] ? T[K] : Exclude<T[K], undefined> ]\n}[keyof T]\n")])])]),n("p",[e._v("这道题不算特别难，不过不清楚思路确实不知道从哪里下手（🤣我就是这样）")])])}),[],!1,null,null,null);t.default=s.exports}}]);