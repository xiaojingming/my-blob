(window.webpackJsonp=window.webpackJsonp||[]).push([[58],{611:function(e,t,s){"use strict";s.r(t);var n=s(13),a=Object(n.a)({},(function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h3",{attrs:{id:"tupletonestedobject"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#tupletonestedobject"}},[e._v("#")]),e._v(" TupleToNestedObject")]),e._v(" "),s("p",[s("a",{attrs:{href:"https://github.com/type-challenges/type-challenges/blob/main/questions/03188-medium-tuple-to-nested-object/README.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("type-challenge-TupleNestedObject github地址"),s("OutboundLink")],1)]),e._v(" "),s("p",[e._v("难度：中等")]),e._v(" "),s("h4",{attrs:{id:"题目描述"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#题目描述"}},[e._v("#")]),e._v(" 题目描述")]),e._v(" "),s("p",[e._v("Given a tuple type T that only contains string type, and a type U, build an object recursively.")]),e._v(" "),s("blockquote",[s("p",[e._v("(实现"),s("code",[e._v("TupleToNestedObject<T, U>")]),e._v("，其中"),s("code",[e._v("T")]),e._v("只能接收字符串类型数组，并且生成一个递归的对象)")])]),e._v(" "),s("p",[e._v("For example:")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("type a = TupleToNestedObject<['a'], string> // {a: string}\ntype b = TupleToNestedObject<['a', 'b'], number>\n// {a: {b: number}}\ntype c = TupleToNestedObject<[], boolean>\n// boolean. if the tuple is empty, just return the U type\n")])])]),s("p",[e._v("根据题意，当"),s("code",[e._v("T")]),e._v("为空数组时，直接返回类型"),s("code",[e._v("U")]),e._v("，先实现这个功能")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("type TupleToNestedObject<T extends string[], U> = T extends [infer First, ...infer Rest]\n  ? <Others>\n  : U;\n")])])]),s("p",[e._v("我们需要循环"),s("code",[e._v("Rest")]),e._v("来递归生成对象")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("type TupleToNestedObject<T extends string[], U> = T extends [infer First, ...infer Rest]\n  ? {\n    [K in First & string]: TupleToNestedObject<Rest extends string[] ? Rest : [], U>\n  }\n  : U;\n")])])]),s("p",[e._v("这样就可以实现上面的功能啦。")])])}),[],!1,null,null,null);t.default=a.exports}}]);