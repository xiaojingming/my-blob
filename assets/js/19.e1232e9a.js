(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{571:function(e,t,n){"use strict";n.r(t);var s=n(13),a=Object(s.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h3",{attrs:{id:"chunk"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#chunk"}},[e._v("#")]),e._v(" Chunk")]),e._v(" "),n("p",[n("a",{attrs:{href:"https://github.com/type-challenges/type-challenges/blob/main/questions/04499-medium-chunk/README.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("type-challenge-Chunk github地址"),n("OutboundLink")],1)]),e._v(" "),n("p",[e._v("难度：中等")]),e._v(" "),n("h4",{attrs:{id:"题目描述"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#题目描述"}},[e._v("#")]),e._v(" 题目描述")]),e._v(" "),n("p",[e._v("Do you know lodash? Chunk is a very useful function in it, now let's implement it. Chunk<T, N> accepts two required type parameters, the T must be a tuple, and the N must be an integer >=1")]),e._v(" "),n("blockquote",[n("p",[e._v("(实现"),n("code",[e._v("lodash")]),e._v("的"),n("code",[e._v("Chunk")]),e._v("函数)")])]),e._v(" "),n("p",[e._v("For example:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("type exp1 = Chunk<[1, 2, 3], 2> // expected to be [[1, 2], [3]]\ntype exp2 = Chunk<[1, 2, 3], 4> // expected to be [[1, 2, 3]]\ntype exp3 = Chunk<[1, 2, 3], 1> // expected to be [[1], [2], [3]]\n")])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("type Chunk<\n  T extends any[],\n  K extends number,\n  R extends any[] = [],\n> = T extends [infer First, ...infer Others]\n  ? xxx\n  : [R];\n")])])]),n("p",[e._v("在"),n("code",[e._v("Chunk")]),e._v("中加入了第三个参数"),n("code",[e._v("T")]),e._v("用于保每一次执行的结果，"),n("code",[e._v("T")]),e._v("每次循环都会减少第一项，当"),n("code",[e._v("T")]),e._v("为空的时候，即代表顺换结束，返回"),n("code",[e._v("[R]")]),e._v("，接下来就是如何实现这样的一个循环。\n接下来我们通过"),n("code",[e._v("R['length']")]),e._v("来判断是否截取完毕，如果没有截取完毕，递归执行"),n("code",[e._v("Chunk")]),e._v("，将"),n("code",[e._v("Others")]),e._v("作为"),n("code",[e._v("Chunk")]),e._v("第一个参数传递，其中"),n("code",[e._v("R")]),e._v("需要将上一次的"),n("code",[e._v("R")]),e._v("和"),n("code",[e._v("First")]),e._v("第一项加入")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("type Chunk<\n  T extends any[],\n  K extends number,\n  R extends any[] = [],\n> = T extends [infer First, ...infer Others]\n  ? R['length'] extends K\n    ? xxx\n    : Chunk<Others, K, [...R, First]>\n  : [R];\n")])])]),n("p",[e._v("然后就是处理截取完毕的情况，将截取完成的"),n("code",[e._v("R")]),e._v("返回，并继续递归剩余的部分，最后通过扩展运算符展开即可")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("type Chunk<\n  T extends any[],\n  K extends number,\n  R extends any[] = [],\n> = T extends [infer First, ...infer Others]\n  ? R['length'] extends K\n    ? [R, ...Chunk<T, K>]\n    : Chunk<Others, K, [...R, First]>\n  : [R];\n")])])]),n("p",[e._v("😥感觉还是不太好理解的")])])}),[],!1,null,null,null);t.default=a.exports}}]);