(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{577:function(e,t,n){"use strict";n.r(t);var a=n(13),s=Object(a.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h3",{attrs:{id:"flattendepth"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#flattendepth"}},[e._v("#")]),e._v(" FlattenDepth")]),e._v(" "),n("p",[n("a",{attrs:{href:"https://github.com/type-challenges/type-challenges/blob/main/questions/03243-medium-flattendepth/README.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("type-challenge-FlattenDepth github地址"),n("OutboundLink")],1)]),e._v(" "),n("p",[e._v("难度：中等")]),e._v(" "),n("h4",{attrs:{id:"题目描述"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#题目描述"}},[e._v("#")]),e._v(" 题目描述")]),e._v(" "),n("p",[e._v("Recursively flatten array up to depth times.")]),e._v(" "),n("blockquote",[n("p",[e._v("(实现"),n("code",[e._v("FlattenDepth<T, N>")]),e._v("，根据参数"),n("code",[e._v("N")]),e._v("递归扁平数组"),n("code",[e._v("T")]),e._v(")")])]),e._v(" "),n("p",[e._v("For example:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("type a = FlattenDepth<[1, 2, [3, 4], [[[5]]]], 2>\n// [1, 2, 3, 4, [5]]. flattern 2 times\ntype b = FlattenDepth<[1, 2, [3, 4], [[[5]]]]>\n// [1, 2, 3, 4, [[5]]]. Depth defaults to be 1\n")])])]),n("p",[e._v("😂又是不知道怎么做的一道题，与完全扁平不同，需要根据参数来判断扁平化的次数，首先我们先实现只扁平一次的函数：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("type FlattenOnce<T extends any[]> = T extends [infer First, ...infer Rest]\n  ? First extends any[]\n    ? [...First, ...FlattenOnce<Rest>]\n    : [First, ...FlattenOnce<Rest>]\n  : T\n\ntype A = FlattenOnce<[1, 2, [3, [4]]]> // [1, 2, 3, [4]]\n")])])]),n("p",[e._v("接下来我们实现"),n("code",[e._v("FlattenDepth")]),e._v("，因为我们需要使用到"),n("code",[e._v("number")]),e._v("类型，通过数组"),n("code",[e._v("length")]),e._v("来获取，所以我们在"),n("code",[e._v("FlattenDepth")]),e._v("传递第三个参数（数组），用于记录当前次数，并通过和第二个参数进行比较，判断是否递归结束；如果当前次数与第二个参数不一致，将扁平化一次的数组作为第一个参数，递归执行"),n("code",[e._v("FlattenDepth")]),e._v("。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("type FlattenDepth<T extends any[], N extends number = 1, Arr extends any[] = []> = Arr['length'] extends N\n  ? T\n  : FlattenDepth<FlattenOnce<T>, N, [...Arr, '']> // 这里的```''```主要是为了给数组增加一项内容，也可以使用别的进行替换\n")])])]),n("p",[e._v("这样已经能实现功能了，不过在测试用例"),n("code",[e._v("<FlattenDepth<[1, [2, [3, [4, [5]]]]], 19260817>")]),e._v("会出现嵌套过深导致的无法判断类型，我们需要在每次执行先判断数组是否已经扁平化完成，扁平化完成则直接返回数组。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("type FlattenDepth<T extends any[], N extends number = 1, Arr extends any[] = []> = FlattenOnce<T> extends T\n ? T\n : Arr['length'] extends N\n  ? T\n  : FlattenDepth<FlattenOnce<T>, N, [...Arr, '']>\n")])])]),n("p",[e._v("大功告成🤣")])])}),[],!1,null,null,null);t.default=s.exports}}]);