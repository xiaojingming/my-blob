(window.webpackJsonp=window.webpackJsonp||[]).push([[36],{589:function(e,a,t){"use strict";t.r(a);var n=t(13),r=Object(n.a)({},(function(){var e=this,a=e.$createElement,t=e._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h3",{attrs:{id:"maptypes"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#maptypes"}},[e._v("#")]),e._v(" MapTypes")]),e._v(" "),t("p",[t("a",{attrs:{href:"https://github.com/type-challenges/type-challenges/blob/main/questions/05821-medium-maptypes/README.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("type-challenge github地址"),t("OutboundLink")],1)]),e._v(" "),t("p",[e._v("Implement MapTypes<T, R> which will transform types in object T to different types defined by type R which has the following structure")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("type StringToNumber = {\n  mapFrom: string; // value of key which value is string\n  mapTo: number; // will be transformed for number\n}\n")])])]),t("blockquote",[t("p",[e._v("(实现"),t("code",[e._v("MapTypes<T, R>")]),e._v("泛型，其中"),t("code",[e._v("T")]),e._v("是对象类型并会根据类型"),t("code",[e._v("R")]),e._v("转换为指定类型，"),t("code",[e._v("R")]),e._v("的类型如上所示)")])]),e._v(" "),t("p",[e._v("For example:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("type StringToNumber = { mapFrom: string; mapTo: number;}\nMapTypes<{iWillBeANumberOneDay: string}, StringToNumber>\n// gives { iWillBeANumberOneDay: number; }\n")])])]),t("p",[e._v("并且"),t("code",[e._v("R")]),e._v("可以是联合类型")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("type StringToNumber = { mapFrom: string; mapTo: number;}\ntype StringToDate = { mapFrom: string; mapTo: Date;}\nMapTypes<{iWillBeNumberOrDate: string}, StringToDate | StringToNumber>\n// gives { iWillBeNumberOrDate: number | Date; }\n")])])]),t("p",[e._v("如果属性在"),t("code",[e._v("map")]),e._v("中不存在，则直接返回对应的类型")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("type StringToNumber = { mapFrom: string; mapTo: number;}\nMapTypes<{iWillBeANumberOneDay: string, iWillStayTheSame: Function}, StringToNumber>\n// gives { iWillBeANumberOneDay: number, iWillStayTheSame: Function }\n")])])]),t("p",[e._v("虽然这道题目比较长，但是逻辑不是很复杂")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("type MapTypes<T, R extends { mapFrom: unknown, mapTo: unknown }> = {\n  [K in keyof T]: T[K] extends R['mapFrom']\n    ? R['mapTo']\n    : T[K]\n}\n")])])]),t("p",[e._v("这样基本能通过所有的测试用例，但是对于"),t("code",[e._v("R")]),e._v("为联合类型是无法通过的，我们需要实现一个辅助泛型"),t("code",[e._v("Transform")]),e._v("来处理联合类型")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("type Transform<T extends { mapFrom: unknown, mapTo: unknown }, R> = T extends any\n  ? T['mapFrom'] extends R\n    ? T['mapTo']\n    : never\n  : never;\n")])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("type MapTypes<T, R extends { mapFrom: unknown, mapTo: unknown }> = {\n  [K in keyof T]: T[K] extends R['mapFrom']\n    ? Transform<R, T[K]>\n    : T[K];\n}\n")])])]),t("p",[e._v("在GitHub上面还看到了一种更加方便地实现方式，并且不需要使用复制函数")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("type MapTypes<T, R extends { mapFrom: unknown, mapTo: unknown }> = {\n  [K in keyof T]: T[K] extends R['mapFrom']\n    ? Extract<R, { mapFrom: T[K] }>['mapTo']\n    : T[K];\n}\n")])])]),t("p",[e._v("通过"),t("code",[e._v("Extract")]),e._v("从联合类型中指定具体类型来实现"),t("code",[e._v("MapTypes")]),e._v("😂")])])}),[],!1,null,null,null);a.default=r.exports}}]);