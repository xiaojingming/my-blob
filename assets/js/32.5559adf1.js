(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{586:function(e,t,s){"use strict";s.r(t);var n=s(13),a=Object(n.a)({},(function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h3",{attrs:{id:"isunion"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#isunion"}},[e._v("#")]),e._v(" IsUnion")]),e._v(" "),s("p",[s("a",{attrs:{href:"https://github.com/type-challenges/type-challenges/blob/main/questions/01097-medium-isunion/README.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("type-challenge-isUnion github地址"),s("OutboundLink")],1)]),e._v(" "),s("p",[e._v("难度：中等")]),e._v(" "),s("h4",{attrs:{id:"题目描述"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#题目描述"}},[e._v("#")]),e._v(" 题目描述")]),e._v(" "),s("p",[e._v("Implement a type IsUnion, which takes an input type T and returns whether T resolves to a union type.")]),e._v(" "),s("blockquote",[s("p",[e._v("(判断输入类型是否是联合类型)")])]),e._v(" "),s("p",[e._v("For example:")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("type case1 = IsUnion<string>  // false\ntype case2 = IsUnion<string|number>  // true\ntype case3 = IsUnion<[string|number]>  // false\ntype case4 = IsUnion<never> // false\n")])])]),s("p",[e._v("TS在处理泛型为联合类型时会进行分发：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("Extends<'a' | 'b'> == Extends<'a'> | Extends<'b'>\n")])])]),s("p",[e._v("所以可以通过是否进行分发来判断是否是联合类型，那么如何判断是否进行分发了呢？")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("A<T> = T extends T\n如果泛型T是联合类型string | number，分发的结果是(string extends string | number) | (number extends string | number)\n")])])]),s("p",[e._v("但是这样得到的结果都是true，可以使用"),s("code",[e._v("[]")]),e._v("来处理这个问题，如上面表达式中的T，第一个T指的是联合类型中的一项，使用"),s("code",[e._v("[]")]),e._v("包裹后"),s("code",[e._v("[T] extends [T] ? true : false")]),e._v("类型为"),s("code",[e._v("false")]),e._v("，必然与原类型不一致，因此在分发的过程中，使用"),s("code",[e._v("[]")]),e._v("再进行匹配，如果匹配不上，说明存在联合类型。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("type A<T> = T extends T ? [T] extends [T] ? true : false : false;\n")])])]),s("p",[e._v("上述的代码还是存在问题，因为T已经进行分发，"),s("code",[e._v("[T] extends [T]")]),e._v("依然为"),s("code",[e._v("true")]),e._v("，我们需要通过一个默认值来保存原始值")]),e._v(" "),s("p",[e._v("最终代码如下(对于传递never的情况时，认为结果为false)：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("type IsUnion<T, U = T> = IsNever<T> extends false\n  ? T extends U\n    ? [U] extends T ? false : true\n  : false;\n")])])]),s("p",[s("RouterLink",{attrs:{to:"/TypeScript/IsNever.html"}},[e._v("IsNever链接")])],1)])}),[],!1,null,null,null);t.default=a.exports}}]);