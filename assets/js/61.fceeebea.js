(window.webpackJsonp=window.webpackJsonp||[]).push([[61],{614:function(e,t,n){"use strict";n.r(t);var a=n(13),s=Object(a.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h3",{attrs:{id:"zip"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#zip"}},[e._v("#")]),e._v(" Zip")]),e._v(" "),n("p",[n("a",{attrs:{href:"https://github.com/type-challenges/type-challenges/blob/main/questions/04471-medium-zip/README.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("type-challenge-Zip github地址"),n("OutboundLink")],1)]),e._v(" "),n("p",[e._v("难度：中等")]),e._v(" "),n("h4",{attrs:{id:"题目描述"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#题目描述"}},[e._v("#")]),e._v(" 题目描述")]),e._v(" "),n("p",[e._v("In This Challenge, You should implement a type Zip<T, U>, T and U must be Tuple")]),e._v(" "),n("blockquote",[n("p",[e._v("(实现"),n("code",[e._v("Zip<T, U>")]),e._v("，"),n("code",[e._v("T")]),e._v("和"),n("code",[e._v("U")]),e._v("都是元组类型实现类似解构的语法, 返回合并后的新数组)")])]),e._v(" "),n("p",[e._v("For example:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("type exp = Zip<[1, 2], [true, false]> // expected to be [[1, true], [2, false]]\n")])])]),n("p",[e._v("这道题目与之前设计到计算的题目类似，我们都需要使用辅助参数用于进行计数，在这里我们还需要一个参数来保存结果，并通过扩展运算符来展开")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("type Zip<\n  T extends any[],\n  U extends any[],\n  S extends 1[] = [],\n  R extends any[] = [],\n> = S['length'] extends T\n  ? R\n  : Zip<T, U, [1, ...S], [...R, [T[S['length']], U[S['length']]]]>\n")])])]),n("p",[e._v("但是上面的Zip并不能满足测试用例"),n("code",[e._v("Zip<[1, 2, 3], ['1', '2']>")]),e._v("，我们需要在执行递归之前进一步判断U是否已经是最后一项，是的话直接返回R")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("type Zip<\n  T extends any[],\n  U extends any[],\n  S extends 1[] = [],\n  R extends any[] = [],\n> = S['length'] extends T['length']\n  ? R\n  : S['length'] extends U['length']\n    ? R\n    : Zip<T, U, [1, ...S], [...R, [T[S['length']], U[S['length']]]]>;\n")])])]),n("p",[e._v("这样就可以实现效果")])])}),[],!1,null,null,null);t.default=s.exports}}]);