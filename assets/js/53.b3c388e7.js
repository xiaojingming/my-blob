(window.webpackJsonp=window.webpackJsonp||[]).push([[53],{607:function(t,e,s){"use strict";s.r(e);var a=s(13),r=Object(a.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h3",{attrs:{id:"startswith"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#startswith"}},[t._v("#")]),t._v(" StartsWith")]),t._v(" "),s("p",[s("a",{attrs:{href:"https://github.com/type-challenges/type-challenges/blob/main/questions/02688-medium-startswith/README.zh-CN.md",target:"_blank",rel:"noopener noreferrer"}},[t._v("type-challenge-startsWith github地址"),s("OutboundLink")],1)]),t._v(" "),s("p",[t._v("难度：中等")]),t._v(" "),s("h4",{attrs:{id:"题目描述"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#题目描述"}},[t._v("#")]),t._v(" 题目描述")]),t._v(" "),s("p",[t._v("Implement StartsWith<T, U> which takes two exact string types and returns whether T starts with U")]),t._v(" "),s("blockquote",[s("p",[t._v("(实现"),s("code",[t._v("StartsWith<T, U>")]),t._v("，接收两个类型都是string的参数，判断"),s("code",[t._v("T")]),t._v("是否以"),s("code",[t._v("U")]),t._v("开头)")])]),t._v(" "),s("p",[t._v("For example:")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("type a = StartsWith<'abc', 'ac'> // expected to be false\ntype b = StartsWith<'abc', 'ab'> // expected to be true\ntype c = StartsWith<'abc', 'abcd'> // expected to be false\n")])])]),s("p",[t._v("这道题的思路是通过模板字面量和递归来解决")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("type StartsWith<T extends string, U extends string> = U extends `${infer Ustart}${infer Uend}`\n  ? T extends `${infer Tstart}${infer Tend}`\n    ? Tstart extends Ustart\n      ? StartsWith<Tend, Uend>\n      : false\n    : false\n  : true;\n")])])]),s("p",[t._v("其中，第一个条件类型使用来判断第二个参数是否为"),s("code",[t._v("''")]),t._v("，是的话直接返回"),s("code",[t._v("true")]),t._v("，否则继续继续第二个条件类型判断；如果第一个参数为"),s("code",[t._v("''")]),t._v("则返回"),s("code",[t._v("false")]),t._v("，否则继续进行判断；判断两个参数（字符串类型）是否相等，是的话递归继续进行判断，否则返回"),s("code",[t._v("false")]),t._v("。")]),t._v(" "),s("p",[t._v("不过我在别人提交的解答中也看到了一种写法🤔：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("type StartsWith<T extends string, U extends string> = T extends `${U}${string}` ? true : false;\n")])])]),s("p",[t._v("额，好像确实是可以这样实现😂")]),t._v(" "),s("p",[t._v("与"),s("code",[t._v("StartsWith")]),t._v("很类似的"),s("RouterLink",{attrs:{to:"/TypeScript/EndsWith.html"}},[t._v("EndsWith")])],1)])}),[],!1,null,null,null);e.default=r.exports}}]);